# auto-generated by grc.converter

id: radar_estimator_fsk
label: Estimator FSK
category: '[RADAR]/Estimators'

parameters:
-   id: center_freq
    label: Center frequency
    dtype: float
-   id: delta_freq
    label: Delta frequency
    dtype: float
-   id: push_power
    label: Push through power of peaks
    dtype: bool
    default: 'False'
    options: ['True', 'False']

inputs:
-   domain: message
    id: Msg in
    optional: true

outputs:
-   domain: message
    id: Msg out
    optional: true

templates:
    imports: import radar
    make: radar.estimator_fsk(${center_freq}, ${delta_freq}, ${push_power})

documentation: |-
    ######################################################
    ######################################################
    ## Basics of Radar
    The basic flowgraph for many radar applications: first a signal is generated and sent and received with some hardware.
    TX and RX signal are compared with an estimator and the result is displayed on the screen.

    The module uses tagged streams for packaging data and to make sure that corresponding data is processed together in one work function call. In most cases streams are used up to the evaluation of the signal attributes which are used for calculating range, velocity or azimuth. This attributes are most often peaks of a FFT spectrum. After this point there is no use for tagged streams and it is practical to switch to the message system of GNU Radio.

    To test your flowgraphs without hardware, a simulator for static targets with constant attributes like range and velocity is implemented. The static target simulator has a callback that updates the target's attributes during runtime. It is possible to emulate a moving target if you use sliders for variables in GNU Radio Companion.



    ## Message structure and identifiers
    If the module exchanges messages a standard structure for the data is used. The idea is to tag a dataset with an identifier(symbol). This identifier is a string packed as a polymorphic type (PMT) symbol. Then the data is packed together as a list of two items (the identifier and the data). Multiple datasets can be sent in one message as a list of identifier/data pairs. With this structure the order of the datasets is not important and it is easy to enlarge or manipulate a message without have to think about the processing in the following blocks.

    The data structure looks like this:
    > A single dataset as identifier data pair: [<+symbol0+>, <+data0+>]
    > A whole message with multiple datasets: [[<+symbol0+>, <+data0+>], [<+symbol1+>, <+data1+>], ... ]

    ### Signal information identifiers are the following strings:
    > rx_time = Timestamp of the RX signal
    > frequency = Frequency information of peaks in a FFT spectrum
    > power = Amplitude (magnitude square) of peaks, e. g. in a FFT spectrum or within matrix processing
    > phase = Phase of the complex value of peaks in a FFT spectrum
    > axis_x = Number of bins on x axis for matrix processing
    > axis_y = Number of bins on y axis for matrix processing

    ### Target information identifiers are the following strings:
    > range = Target range
    > velocity = Target velocity



    ## USRP Echotimer
    You can use the USRP Echotimer. This block takes a tagged stream and ensures that this package is sent and received synchronously. Further information in the section 'USRP Echotimer'.

    The USRP Echotimer is a UHD interface for USRPs. Known well working devices are N210, B210 and USRP 2. Check out www.ettus.com for more information about the hardware.

    Basically the Echotimer bursts a data packet defined as tagged stream. Synchronously a packet with the same length is received. The receive time is given with a stream tag on the first item of the tagged stream with the identifier 'rx_time'. This is put into practice with a send and receive command on a shared point of time on all USRPs. Therefore the time has to be synchronized on all used devices. This can be done with a MIMO cable or with a GPS clock. The strings are 'mimo' or 'gpsdo' for the time source. Either you can choose the GPS clock on both devices or set one clock on 'internal' as master and set the clock of the slave device over MIMO cable.

    Look at the GNU Radio Companion flowgraph samples in '/examples/usrp' for reference. Mostly all values and strings are push through and used without a change within the UHD API. Therefore the UHD API documentation is also a good reference.



    ## Caveats
    Radar applications often need huge buffer sizes. Therefore you have to do two things to push the maximum buffer size to the maximum. First you have to set the maximum output buffer of all blocks in the flowgraph on two times of the value that you need. With this you can use buffer of about 2^17 float complex items. This number depends on your system. In GNU Radio Companion you can set this value in the properties of the blocks or you use the call '<+block+>.set_min_output_buffer(<+value+>)' in a python flowgraph.

    If you need greater buffer sizes you have to increase the limit of a single shared memory segment. The commands are given in a bash script in gr-radar/examples/setup/setup_core. If you want to set the parameters in gr-radar/examples/setup/setup_core on every system start, edit /etc/sysctl.conf with following lines.

    net.core.rmem_max=50000000
    net.core.wmem_max=1048576
    kernel.shmmax=2147483648



    ## Documentation
    For full documentation build the toolbox and open `build/docs/doxygen/html/index.html` in any web browser.

    If there is any need to rebuild the documentation with doxygen go to gr-radar/docs/doxygen and run 'doxygen Doxyfile.in'. The documentation is not rebuild with every build of the toolbox (unlike the default out-of-tree module behaviour). The actual documentation shall be included in the repository.



    ## Development platform
    GNU Radio maint-3.8
    UHD 3.15
    Ubuntu 18.04

    ## Contact
    Stefan Wunsch
    stefan.wunsch[at]student.kit.edu
    https://grradar.wordpress.com/

    ######################################################
    ######################################################

file_format: 1
